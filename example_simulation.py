"""Offline example for exercising the modular EMA/SMA strategy package.

This script mocks the broker layer so you can feed synthetic bars into the
strategy and inspect the generated orders without connecting to Alpaca. It is
useful for verifying configuration tweaks (indicator periods, allocation rules,
etc.) before running `runner.py` with live credentials.
"""
from __future__ import annotations

import asyncio
from dataclasses import dataclass
from datetime import datetime, timedelta
from types import SimpleNamespace
from typing import Dict, Iterable, List

from bootstrap import ensure_requirements

# Ensure dependencies are present before importing third-party modules
ensure_requirements()

from alpaca.trading.enums import OrderSide
from config import AllocationConfig, IndicatorConfig, RiskConfig, StrategyConfig
from indicators import IndicatorSet
from risk import RiskManager
from strategy import EmaSmaStrategy


@dataclass(slots=True)
class DummyBar:
    """Lightweight replacement for Alpaca ``Bar`` objects."""

    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int = 0


class FakeBroker:
    """Minimal broker implementation that records orders in memory."""

    def __init__(self, config: StrategyConfig, *, buying_power: float = 10_000):
        self._strategy = config
        self._buying_power = buying_power
        self.orders: List[SimpleNamespace] = []
        self.positions: Dict[str, int] = {}

    # --- interface expected by the strategy / risk manager -----------------
    @property
    def strategy(self) -> StrategyConfig:
        return self._strategy

    def get_account(self):
        return SimpleNamespace(buying_power=str(self._buying_power))

    def get_position(self, symbol: str):
        qty = self.positions.get(symbol, 0)
        if qty == 0:
            return None
        return SimpleNamespace(symbol=symbol, qty=str(qty))

    def submit_market_order(self, *, symbol: str, qty: int, side: OrderSide, time_in_force):
        if side == OrderSide.BUY:
            self.positions[symbol] = self.positions.get(symbol, 0) + qty
            self._buying_power -= qty  # pretend each share costs $1 for simplicity
        else:
            self.positions[symbol] = self.positions.get(symbol, 0) - qty
            self._buying_power += qty
        self.orders.append(
            SimpleNamespace(symbol=symbol, qty=qty, side=side.name, tif=str(time_in_force))
        )

    def close_position(self, symbol: str):
        qty = self.positions.pop(symbol, 0)
        if qty:
            self.orders.append(SimpleNamespace(symbol=symbol, qty=abs(qty), side="CLOSE", tif="DAY"))

    def close_all_positions(self, cancel_orders: bool = True):  # noqa: ARG002 - parity with real client
        for symbol in list(self.positions):
            self.close_position(symbol)

    def to_time_in_force(self, value: str):
        return value.upper()


# ---------------------------------------------------------------------------
# Helpers for generating sample data

def generate_seed_bars(start: datetime, prices: Iterable[float]) -> List[DummyBar]:
    bars: List[DummyBar] = []
    for index, price in enumerate(prices):
        ts = start + timedelta(minutes=index)
        bars.append(
            DummyBar(
                timestamp=ts,
                open=price,
                high=price * 1.01,
                low=price * 0.99,
                close=price,
            )
        )
    return bars


def generate_test_stream(start: datetime) -> List[DummyBar]:
    """Create a simple sequence where EMA crosses above and below the SMA."""

    prices = [50, 50.5, 50.8, 51, 51.5, 52, 51.8, 51.2, 50.9, 50.3, 49.8, 49.5]
    return generate_seed_bars(start, prices)


async def run_simulation() -> None:
    # Customise the configuration the same way you would for live trading.
    strategy_config = StrategyConfig(
        bullish_symbol="SOXL",
        bearish_symbol="SOXS",
        indicators=IndicatorConfig(ema_period=3, sma_period=5, atr_period=14, seed_bars=5),
        allocation=AllocationConfig(cash_fraction=0.5, order_time_in_force="day"),
        risk=RiskConfig(close_all_at=None),
    )

    broker = FakeBroker(strategy_config)
    indicators = IndicatorSet.from_config(
        ema_period=strategy_config.indicators.ema_period,
        sma_period=strategy_config.indicators.sma_period,
        atr_period=strategy_config.indicators.atr_period,
    )
    risk_manager = RiskManager(broker, strategy_config.risk)
    strategy = EmaSmaStrategy(broker, indicators, risk_manager)

    bars = generate_test_stream(datetime(2023, 1, 3, 9, 30))
    seed = bars[: strategy_config.indicators.seed_bars]
    live = bars[strategy_config.indicators.seed_bars :]

    indicators.seed_from_bars(seed)

    for bar in live:
        await strategy.on_bar(bar)

    print("Orders generated by the strategy:\n")
    for order in broker.orders:
        print(f"{order.side:>4} {order.qty:>4} {order.symbol} (TIF={order.tif})")

    print("\nFinal simulated positions:")
    for symbol, qty in broker.positions.items():
        print(f"  {symbol}: {qty} shares")


if __name__ == "__main__":
    asyncio.run(run_simulation())
